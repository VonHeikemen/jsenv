const execa = require('execa');

const escape = str => str.replace(/ /g, '\\ ');

function shell(exec, options) {
  return (pieces, ...args) => {
    let cmd = pieces[0]; 
    let i = 0;
    while (i < args.length) {
      if(Array.isArray(args[i])) {
        cmd += args[i].join(' ');
        cmd += pieces[++i];
      } else {
        cmd += args[i] + pieces[++i];
      }
    }
  
    return exec(parse_cmd(cmd), options);
  }
}

// If you have any idea how to improve this share your ideas with me here:
// https://dev.to/vonheikemen/parse-shell-commands-in-javascript-with-tagged-templates-1g5a
function parse_cmd(str) {
  let result = [];
  let log_matches = false;

  let regex = /(([\w-/_~\.]+)|("(.*?)")|('(.*?)'))/g;
  let groups = [2, 4, 6];
  let match;

  while ((match = regex.exec(str)) !== null) {
    // This is necessary to avoid infinite loops with zero-width matches
    if (match.index === regex.lastIndex) {
      regex.lastIndex++;
    }

    // For this to work the regex groups need to be mutually exclusive 
    for (let group of groups) {
      if(match[group]) {
        result.push(match[group]);
      }
    }
  }
  
  return result;
}
  

const run_cmd = ([cmd, ...args], options) => execa.sync(cmd, args, options);
const sh = shell(run_cmd, { stdio: 'inherit' });
sh.parser = parse_cmd;

sh.quiet = shell(run_cmd);
sh.run = (pieces, ...args) => sh.quiet(pieces, ...args).stdout;
sh.build = shell;
sh.safe = (pieces, ...args) => {
  try {
    return sh(pieces, ...args);
  } catch (e) {
    return e
  }
};

module.exports = sh;

